$schema: "https://json-schema.org/draft/2020-12/schema"
$id: https://raw.githubusercontent.com/markschl/snakecharmer/main/workflow/config.schema.yaml
description: Snakecharmer configuration
properties:
  software:
    type: object
    properties:
      usearch:
        type: object
        properties:
          binary:
            type: string
            default: usearch
            description:
                USEARCH binary name/path (download from https://drive5.com/usearch).
                The default is 'usearch', assuming that the program is accessible
                in $PATH. Alternatively, an absolute or relative path
                (relative to analysis directory containing 'config') can be
                specified.
      qiime:
        type: object
        properties:
          conda_env:
            type: string
            description: Name of QIIME2 conda environment to use, e.g. qiime2-2022.8
        additionalProperties: false
        description: QIIME2 software settings (optional, only required if QIIME2 is used)
      amptk:
        type: object
        properties:
          conda_env:
            type: string
            description: Name of Amptk conda environment to use, e.g. "amptk"
        description: Amptk software settings (optional, only required if Amptk is used)
        additionalProperties: false
    additionalProperties: false

  input:
    $defs:
      input:
        type: object
        $dynamicAnchor: input
        properties:
          sample_file:
            type: string
            description: >
              Path to a sample file with one forward 
          sample_pattern:
            type: string
            description: >
              Naming pattern for input files (required to recognize sample name and
              read number)
          directories:
            type: array
            items: { type: string }
            description: >
              List of directories to search (recursively or not, depending on 
              recursive setting)
          patterns:
            type: array
            items: { type: string }
            description: >
              List of glob patterns that should collectively match input files
              (in conjunction with "directories"). Unlimited directory depth matching
              with /**/ can be done if "recursive" is true
          recursive:
            type: boolean
            default: false
            description: >
              Activate/deactivate recursive search in directories or pattern search
              in directories at unlimited depth using /**/ (see "directories" and 
              "patterns")
          paired_filter:
            type: string
            enum: [fwd-only, rev-only]
            description: >
              Keep only forward/R1 (fwd-only) or reverse/R2 
              (rev-only) read files in a paired layout, resulting 
              in a single-end layout. This setting does not affect 
              samples that are already in single-end mode.
              If only keeping reverse/R2 reads, the resulting layout name will
              actually be "single_rev", indicating that the reads do contain
              the reverse primer and not the forward primer.
        additionalProperties: false
        oneOf:
          - required: [sample_file]
          - required: [sample_pattern, directories]
          - required: [sample_pattern, patterns]
    type: object
    patternProperties:
      ^(illumina)$:
        if:
          required: ["sample_pattern"]
        then:
          "$dynamicRef": "#input"
        else:
            patternProperties:
              ^\w+$:
                "$dynamicRef": "#input"                
    additionalProperties: false
  
  workflows:
    type: object
    patternProperties:
      ^(\w+)$:
        type: object
        properties:
          cluster:
            type: string
            enum: [usearch_unoise3, qiime_dada2, amptk_unoise3, amptk_dada2]
          taxonomy:
            oneOf:
              - { type: string, enum: [default], default: default }
              - 
                type: object
                properties:
                  dbs:
                    type: object
                    patternProperties: 
                      ^(\w+)$:
                        type: array
                        items: { type: string }
                        minItems: 1
                  methods:
                    type: array
                    items: { type: string }
                    minItems: 1
                required: [dbs, methods]
                additionalProperties: false
                description: >
                  If "default", all taxonomy databases (defined in taxonomy_dbs)
                  and assignment methods (see taxonomy_methods) are used. 
                  Alternatively, a subset can be specified
                  (dbs: marker: [list of databases], and methods: [list of metods])
          settings:
            type: object
            # note: References don't work, but referencing $anchor works.
            #   However, validating these sub-schemas would require all
            #   properties in "required" directives to be actually set, which
            #   is too restrictive.
            # properties:
            #   compare: { $dynamicRef: "#/compare" }
            #   primers: { $dynamicRef: "#/primers" }
            #   filter: { $dynamicRef: "#/filter" }
            #   usearch: { $dynamicRef: "#/usearch" }
            #   dada2: { $dynamicRef: "#/dada2" }
            #   ITSx: { $dynamicRef: "#/ITSx" }
            # additionalProperties: false
            description: >
              Workflow-specific settings that should override different default
              settings specified below (compare, primers, pool_raw, filter, usearch, dada2
              and ITSx)
        required: [cluster, taxonomy]
        additionalProperties: false
    additionalProperties: false

  # qc:
  #   type: object
  #   properties:
  #     fastqc:
  #       type: object
  #       properties:
  #         random_subset:
  #           type: integer
  #           description: >
  #             (number) Only supply a random subset of sequences to FastQC in
  #             order to speed things up.

  pool_raw:
    type: boolean
    default: false
    description: >
      Should duplicate files (samples with same name, but in different directory) 
      be pooled, or should a suffix number be added to make the samples unique?

  compare:
    type: object
    $defs:
        defaults:
          type: object
          properties:
            ident_threshold:
              type: number
              minimum: 0
              maximum: 1
            maxhits:
              type: integer
              minimum: 1
              default: 1
            maxaccepts:
              type: integer
              minimum: 1
              default: 64
            maxrejects:
              type: integer
              minimum: 1
              default: 64
    
    properties:
      default_settings:
        $dynamicRef: "#/compare/$defs/defaults"
    if:
      required: [default_settings]
    else:
      patternProperties:
        ^(\w+)$:
          type: object
          properties:
            file:
              type: string
          additionalProperties:
            $dynamicRef": "#/compare/$defs/defaults"
        additionalProperties: false
    minProperties: 1
      
  primers:
    type: object
    properties:
      trim_settings:
        type: object
        properties:
          min_overlap:
            type: integer
            minimum: 5
          max_error_rate:
            type: number
            exclusiveMinimum: 0
            maximum: 1
        required: [min_overlap, max_error_rate]
        additionalProperties: false
    if:
      required: [trim_settings]
    else:
      patternProperties:
        ^(\w+)$:
          type: object
          properties:
            forward:
              type: array
              items:
                type: object
                patternProperties:
                  ^(\w+)$:
                    type: string
              minItems: 1
            reverse:
              type: array
              items:
                type: object
                patternProperties:
                  ^(\w+)$:
                    type: string
              minItems: 1
            combinations:
              oneOf:
                - { type: string, enum: [default], default: default }
                - 
                  type: array
                  items: { type: string }
                  minItems: 1
          required: [forward, reverse, combinations]
          additionalProperties: false
      minProperties: 1
      additionalProperties: false

  taxonomy_dbs:
    type: object
    patternProperties:
      ^(\w+)$:
        type: object
        patternProperties:
          ^(\w+)$:
            type: object
            properties:
              db: { type: string }
              defined: { type: string }
            required: [ db ]
            additionalProperties: false
        additionalProperties: false
    additionalProperties: false

  taxonomy_methods:
    type: object
    patternProperties:
      ^(\w+)$:
        type: object
        properties:
          method:
            type: string
            enum: [sintax_usearch, qiime_sklearn]
          confidence:
            type: number
            minimum: 0
            maximum: 1
          program:
            type: string
            enum: [vsearch, usearch]
            default: vsearch
        required: [method, confidence]
        additionalProperties: false
    additionalProperties: false

  filter:
    type: object
    properties:
      min_length:
        type: integer
        minimum: 1
    required: [min_length]
    additionalProperties: false

  usearch:
    type: object
    properties:
      merge:
        type: object
        properties:
          overlap_ident:
            type: integer
            minimum: 0
            maximum: 100
          max_diffs:
            type: integer
            minimum: 0
          expected_length:
            type: integer
            minimum: 1
          program:
            type: string
            enum: [vsearch, usearch]
            default: vsearch
        required: [overlap_ident, max_diffs, expected_length]
        additionalProperties: false
      filter:
        type: object
        properties:
          max_error_rate:
            type: number
            minimum: 0
            maximum: 1
        required: [max_error_rate]
        additionalProperties: false
      unoise:
        type: object
        properties:
          min_size:
            type: number
            minimum: 1
          program:
            type: string
            enum: [vsearch, usearch]
            default: vsearch
        required: [min_size]
        additionalProperties: false
      otutab:
        type: object
        properties:
          maxaccepts:
            type: integer
            minimum: 1
          maxrejects:
            type: integer
            minimum: 1
          ident_threshold:
            type: number
            minimum: 0
            maximum: 1
          program:
            type: string
            enum: [vsearch, usearch]
            default: vsearch
        required: [maxaccepts, maxrejects, ident_threshold]
        additionalProperties: false
    additionalProperties: false
    
  dada2:
    type: object
    properties:
      trunc_qual:
        type: number
        minimum: 0
      max_err_fwd:
        type: number
        minimum: 0
      max_err_rev:
        type: number
        minimum: 0
      trunclen_fwd:
        type: integer
        minimum: 0
      trunclen_rev:
        type: integer
        minimum: 0
      chimera_method:
        type: string
        enum: [consensus, per-sample, pooled]
      pooling_method:
        type: string
        enum: [independent, pseudo, pooled]
      merge_maxdiffs:
        type: integer
        minimum: 0
    required: [trunc_qual, max_err_fwd, max_err_rev, trunclen_fwd, trunclen_rev, pooling_method, chimera_method, merge_maxdiffs]
    additionalProperties: false

  ITSx:
    type: object
    properties:
      organism_groups:
        type: string
        description: >
          Taxonomic groups to include (see ITSx manual) or "all". "all" is
          the slowest setting but may be best unless you are sure that there
          are only sequences from certain groups.
      "e-value":
        type: number
        exclusiveMinimum: 0.0
        description: >
          Domain E-value cutoff in HMMER search for sequence to be included
          in the output (ITSx default: 1.0e-5)
      allow_single_domain:
        type: string
        default: 1e-9,0
      complement:
        type: string
        enum: [T, F]
        default: F  # ITSx uses T (true) as default, but we know the orientation of our amplicon
      heuristics:
        type: string
        enum: [T, F]
        default: F
      graphical:
        type: string
        enum: [T, F]
        default: F  # ITSx has T as default
      fasta:
        type: string
        enum: [T, F]
        default: T
      preserve:
        type: string
        enum: [T, F]
        default: F
      save_regions:
        type: string
        enum: [SSU, ITS1, 5.8S, ITS2, LSU, all, none]
        default: all  # ITSx has only ITS1,ITS2 as default
      partial:
        type: integer
        minimum: 0
        default: 50  # ITSx has 0 as default
    required: [organism_groups, e-value]
    additionalProperties: false

  # taxonomy.yaml
  taxonomy_db_sources:
    type: object
    patternProperties:
      ^(\w+)$:
        type: object
        properties:
          format:
            type: string
            enum: [unite_otus, midori, gtdb, utax, qiime, qiime_qza, idtaxa, qiime_nb]
        required: [format]
    additionalProperties: false

additionalProperties: false

required: [software, input, workflows, primers, pool_raw, compare,
          taxonomy_dbs, taxonomy_methods, filter, usearch, dada2,
          taxonomy_db_sources]
