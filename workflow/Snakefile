from snakemake.utils import min_version
from snakemake.utils import validate


min_version("7.14.0")


##### configuration #####


configfile: "config/config.yaml"
configfile: "config/taxonomy.yaml"


validate(config, "config.schema.yaml")


##### load rules #####


include: "rules/common.smk"
include: "rules/qc.smk"

if "usearch" in config["software"]:
    include: "rules/usearch.smk"

if "qiime" in config["software"]:
    include: "rules/qiime.smk"

if "amptk" in config["software"]:
    include: "rules/amptk.smk"


include: "rules/taxonomy.smk"


include: "rules/other.smk"


#### Paths ####


taxdirs = lambda sub_path, ext: result_paths(lambda marker, _, p: expand(
    "/{sub_path}/{name}.{ext}",
    sub_path=sub_path,
    ext=ext,
    name=expand("{tax[db_name]}-{tax[assign][method]}-{tax[method_name]}", tax=p["taxonomy"][marker].values())
))


#### target rules #####

from itertools import chain


rule config:
    input:
        expand("results/{workflow}/config.yaml", workflow=cfg.workflows),


rule samples:
    input:
        expand("results/{workflow}/samples.yaml", workflow=cfg.workflows),


rule unique_samples:
    input:
        rules.collect_unique_files.output,


rule quality:
    input:
        multiqc=[
            "results/_qc/multiqc_{run}_{layout}/multiqc_report.html".format(**r)
            for r in cfg.get_runs(pooled=False)
        ],


rule denoise:
    input:
        config=rules.config.input,
        samples=rules.samples.input,
        qual=rules.quality.input,
        multiqc=list(run_results("/_qc/multiqc_report.html", pooled=True)),
        results=lambda _: result_paths((
            "/denoised.fasta",
            "/denoised_otutab.txt.gz",
            "/denoised.biom",
        )),
        stats=expand("results/{workflow}/sample_report.tsv", workflow=cfg.workflows, allow_missing=True),
        data_dir=expand("results/{workflow}/.outdirs", workflow=cfg.workflows),


rule taxonomy:
    input:
        lambda _: taxdirs("taxonomy", ("txt.gz", "biom.gz")),
        lambda _: taxdirs("taxonomy/fasta", ("fasta.gz"))


rule ITS:
    input:
        lambda _: result_paths("/ITSx/out.positions.txt"),


rule cmp:
    input:
        lambda _: result_paths(lambda _m, _p, _config: expand(
                "/cmp/{db}.{ext}",
                db=[cmp for cmp in _config["settings"]["compare"] if cmp != "defaults"],
                ext=("txt", "bam")
        )),


# commands for cleaning up


localrules:
    clean,
    clean_all,


rule clean:
    shell:
        "rm -Rf input processing logs"


rule clean_all:
    shell:
        "rm -Rf results input unique_samples processing logs refdb"
